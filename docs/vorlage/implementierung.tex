\iffalse
In diesem Kapitel wird die konkrete Implementierung des im Kapitel
\ref{cha:loesungskonzept} entwickelten Lösungskonzepts beschrieben.
Hierbei wird auf die konkret verwendeten Entwicklungswerkzeuge etc. 
Bezug genommen.

Bei Software-Projekten besteht dieses Kapitel typischerweise aus den 
Phasen Implementierung \& Test im \ac{rup}.

Zum Beispiel kann man hier auch ein kleines Listing einfügen.

\begin{lstlisting}[language=c,%
                   caption={Überschrift des Quelltexts}]
#include<stdio.h>

int main() {
    // Kommentar
    int answer = 20 << 1;
    answer += 2;
    printf("Hallöchen Welt!\n");
    printf("Die Antwort ist: %d\n", answer);
    return 0;
}
\end{lstlisting}

Manchmal hilft auch eine kleine Tabelle:

\begin{table}[htbp]
\centering
\begin{tabular}{|l|r|}
\hline
\textbf{Messwert a} & \textbf{Messwert b} \\ \hline
9 & 5 \\ \hline
1 & 4 \\ \hline
1 & 3 \\ \hline
\end{tabular}
\caption{Überschrift der Tabelle}
\label{tab:my-table}
\end{table}

Details siehe Tabelle~\ref{tab:my-table}.
\fi

\section{Backend}
\label{sec:backend}

Der bereits beschriebene eine Endpunkt im Backend ließt in Zeile 6 bis 9 alle benötigten Werte aus dem Request Body aus.
Mit diesen Daten wird dann ein neues Objekt vom Typ DatabaseAnalysis erstellt.
In diesem Objekt wird anschließend die Funktion connect aufgerufen, welche Versucht, sich mit der spezifizierten MongoDB Datenbank zu verbinden.
Entsprechend dem Resultat wird entweder ein Fehlercode zurückgegeben oder die Datenbank analysiert und das Resultat der Analyse im JSON-Format im Request Body zurückgegeben.

\begin{lstlisting}[language=python, caption={app.py},label={lst:backend_app}]
    app = Flask("Mongodb Visualization Tool")
    CORS(app)

    @app.post("/connect")
    def get_tables_and_keys():
        connection_string = request.json.get("connection_string")
        database_name = request.json.get("database")
        analyse_ref = request.json.get("analyse_ref")
        sort_method = request.json.get("sort_method")

        db_analysis = DatabaseAnalysis(connection_string, database_name, analyse_ref, sort_method)
        connection_successful = db_analysis.connect()
        if not connection_successful:
            return Response(status=406)

        document_dict = db_analysis.analyse()

        return json.dumps(document_dict)
\end{lstlisting}

Die Methode connect der Klasse DatabaseAnalysis nutzt  den MongoDB Client, um eine Verbindung zu einer MongoDB Datenbank mit dem spezifizierten Connection String und dem Datenbanknamen herzustellen.
Wenn die Verbindung nach 5 Sekunden noch nicht steht, wird der Versuch abgebrochen und False zurückgegeben.
Ansonsten werden die verbundene Datenbank und der verbundene Client im Objekt gespeichert und True zurückgegeben.

\begin{lstlisting}[language=python, caption={DatabaseAnalysis.connect},label={lst:backend_connect}]
    def connect(self, connection_string, database):
        try:
            self.mongodb_client = MongoClient(connection_string, serverSelectionTimeoutMS=5000)
            self.database = self.mongodb_client[database]
        except pymongo.errors.ServerSelectionTimeoutError:
            return False
        return True
\end{lstlisting}

In der Methode analyse derselben Klasse werden daraufhin alle Collection Namen in der Datenbank ausgelesen.
Für jeden Namen wird die Collection mit diesem Namen als Dictionary ausgelesen.
Dieses Dictionary enthält wiederum alle Dokumente der Collection.
Jedes Dokument wird in der Methdode ProcessedCollection.add\_doc analysiert und, falls noch nicht vorhanden, der ProcessedCollection hinzugefügt.
Wenn alle Dokumente durchlaufen wurden, wird die Verbindung zur Datenbank geschlossen und die ProcessedCollection wird in ein Dictionary umgewandelt und zurückgegeben.

\begin{lstlisting}[language=python, caption={DatabaseAnalysis.analyse},label={lst:backend_analyse}]
    def analyse(self):
        self.collection_names = self.database.list_collection_names()
        docs_dict = {"collections": []}
        for name in self.collection_names:
            processed_collection = ProcessedCollection(name)
            collection = self.database.get_collection(name)
            documents = collection.find({})
            for document in documents:
                processed_collection.add_doc(document)

            processed_collection .post_processing(sort_method=self.sort_method)
            if self.analyse_ref:
                self.analyse_references(processed_collection)
            docs_dict["collections"] .append(processed_collection.to_dict())
        self.mongodb_client.close()
        return docs_dict
\end{lstlisting}

Die Methdoe analy\_references in DatabaseAnalysis wird nur ausgeführt, wenn der im Endpunkt übergebene Wert analyse\_ref auf True gesetzt ist.
In der Methode selbst werden alle Values aller verarbeiteten Dokumente durchlaufen und überprüft, ob es sich dabei um eine Referenz auf ein anderes Dokument handeln könnte.
Wenn der Datentyp Object ID ist und der Name des Values nicht \_id ist (Es sich also nicht um den Primary Key handelt), wird angenommen, dass der Value eine Referenz ist.
Wenn dies der Fall ist, werden aus den Originaldokumenten, die im Verarbeiteten Dokument abgespeichert sind, die Werte der soeben identifizierten Referent ausgelesen.
Mit diesen Werten wird dann get\_referenced\_collection so lange aufgerufen, bis die Methode einmal nicht None zurückgibt.
get\_referenced\_collection durchläuft die \_id Werte aller (unverarbeiteten) Dokumente und vergleicht diese mit der übergebenen Object ID.
Sobald eine Übereinstimmung gefunden wurde, wird die Collection zurückgegeben, in der sich das Dokument mit der passenden \_id befindet.
Wenn keine Übereinstimmung gefunden wird, dann wird None zurückgegeben.

\begin{lstlisting}[language=python, caption={DatabaseAnalysis.analyse\_references},label={lst:backend_analyse_ref}]
    def analyse_references(self, processed_collection):
        for document in processed_collection.documents:
            for value in document.values:
                if value.val_type == "Object ID" and value.key != "_id":
                    for orig_document in document.original_documents:
                        referenced_collection = self.get_referenced_collection (orig_document.get(value.key))
                        if referenced_collection is not None:
                            value.ref = referenced_collection
                            return

    def get_referenced_collection(self, _id):
        for collection_name in self.collection_names:
            collection = self.database.get_collection(collection_name)
            document = collection.find_one({"_id": _id})
            if document is not None:
                return collection_name
        return None
\end{lstlisting}

Die Methode add\_doc in der Klasse ProcessedCollection erstellt aus dem übergebenen Dictionary ein neues Objekt der Klasse ProcessedDocument.
Wenn sich noch kein Objekt mit den gleichen Werten in der aktuellen ProcessedCollection befindet, wird das ProcessedDocument der ProcessedCollection hinzugefügt.
Ansonsten wird das Attribut count in dem bereits vorhandenen ProcessedDocument Objekt hochgezählt.


\begin{lstlisting}[language=python, caption={ProcessedCollection.add\_doc},label={lst:backend_add_doc}]
    def add_doc(self, document):
        new_doc = ProcessedDocument(document)
        for doc in self.documents:
            if doc == new_doc:
                doc.count += 1
                if doc.document_ages:
                    doc.document_ages .append(new_doc.document_ages[0])
                doc.original_documents .append(new_doc.original_documents[0])
                return
        self.documents.append(new_doc)
\end{lstlisting}

\section{Frontend}
\label{sec:frontend}

\subsection{}
\label{sub:rest_api}

